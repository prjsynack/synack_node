<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>rcv_log live viewer</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 0; padding: 0; background: #111; color: #fff; }

    #top {
      padding: 10px;
      background:#222;
      color: #fff;
      display: flex;
      justify-content: space-between;
      align-items: center;
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      z-index: 10;
    }

    .status-icon {
      font-size: 18px;
      margin-right: 30px;
    }

    #tableWrap { height: calc(100vh - 50px); overflow: auto; background: #111; }
    table { width: 100%; border-collapse: collapse; color: #fff; }
    th, td { padding: 6px 8px; border-bottom: 1px solid #333; font-size: 13px; text-align: left; }
    th { position: sticky; top: 0; background: #222; z-index: 2; }

    th:nth-child(1), td:nth-child(1) { width: 5px; }
    th:nth-child(2), td:nth-child(2) { width: 80px; }
    th:nth-child(3), td:nth-child(3) { width: 140px; }
    th:nth-child(4), td:nth-child(4) { width: 200px; }
    th:nth-child(5), td:nth-child(5) { width: 120px; }
    th:nth-child(6), td:nth-child(6) { width: auto; }

    th:nth-child(1), th:nth-child(3), th:nth-child(6) { color: transparent; }

    .sev-0 { color: #ffffff; }
    .sev-1 { color: #ff5555; }
    .sev-2 { color: #ff9900; }
    .sev-3 { color: #ffff55; }
    .sev-4 { color: #ff55ff; }
    .sev-5 { color: #55ffff; }
    .sev-6 { color: #55ff55; }

    .dot { display:inline-block; width:10px; height:10px; border-radius:50%; vertical-align: middle; }
    .dot.hidden { visibility:hidden; }

    /* FILTRI SEVERITY */
    #filters {
      display: flex;
      gap: 6px;
      margin-left: 30px;
    }

    .filter-btn {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      border: none;
      cursor: pointer;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
    }

    .filter-btn .inner-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: black;
      visibility: hidden;
    }

    .filter-btn.active .inner-dot {
      visibility: visible;
    }

    .filter-btn[data-severity="0"] { background: #ffffff; }
    .filter-btn[data-severity="1"] { background: #ff5555; }
    .filter-btn[data-severity="2"] { background: #ff9900; }
    .filter-btn[data-severity="3"] { background: #ffff55; }
    .filter-btn[data-severity="4"] { background: #ff55ff; }
    .filter-btn[data-severity="5"] { background: #55ffff; }
    .filter-btn[data-severity="6"] { background: #55ff55; }

    /* FILTRI HOSTNAME e IP */
    .text-filter {
      width: 110px;
      height: 22px;
      background: #111;
      border: 1px solid #333;
      color: #fff;
      border-radius: 4px;
      padding: 2px 6px;
      font-size: 12px;
    }

    .text-filter:focus {
      border-color: #55ffff; /* leggero highlight per focus */
      outline: none;
    }

    /* quando si seleziona una riga viene evidenziata */
    tr.selected { background: #333 !important; }

    /* disabilita la selezione del testo quando si seleziona una riga */
    #tbody tr {
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
    }


  </style>
</head>
<body>


<div id="tableWrap">
  <table>
    <thead style="display: none;">
      <tr>
        <th>Active</th><th>Severity</th><th>Traptime</th><th>Hostname</th><th>Agent IP</th><th>Formatline</th>
      </tr>
    </thead>
    <tbody id="tbody"></tbody>
  </table>
</div>

// BARRA INFERIORE
<div id="top">
  <div style="display:flex; align-items:center;">
    <strong>SynAck</strong>
    <div id="filters">
      <button class="filter-btn" data-severity="0"><span class="inner-dot"></span></button>
      <button class="filter-btn" data-severity="6"><span class="inner-dot"></span></button>
      <button class="filter-btn" data-severity="5"><span class="inner-dot"></span></button>
      <button class="filter-btn" data-severity="4"><span class="inner-dot"></span></button>
      <button class="filter-btn" data-severity="3"><span class="inner-dot"></span></button>
      <button class="filter-btn" data-severity="2"><span class="inner-dot"></span></button>
      <button class="filter-btn" data-severity="1"><span class="inner-dot"></span></button>
      <input type="text" id="filterHost" class="text-filter" placeholder="Hostname..." />
      <input type="text" id="filterIP" class="text-filter" placeholder="IP..." />
      <button id="resetFilters" title="Reset filtri" style="margin-left:6px; width:28px; height:28px; border-radius:50%; border:1px solid #333; background:#222; color:#fff; cursor:pointer; font-size:18px; display:flex; align-items:center; justify-content:center;">üßπ</button>
    </div>
  </div>
  <div style="display:flex; align-items:center; gap:6px;">
    <button id="toggleHeaderBtn" title="Mostra/Nascondi header" style="padding:2px; cursor:pointer; background:none; border:none;">
      <svg id="eyeIcon" xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#fff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
        <circle cx="12" cy="12" r="3"></circle>
      </svg>
    </button>

    <span id="statusIcon" class="status-icon">‚ùå</span>
  </div>
</div>

<script>
(() => {
  const wsUrl = (location.protocol==='https:'?'wss':'ws')+'://'+location.host+'/ws';
  const PAGE_SIZE = 50;
  const tbody = document.getElementById('tbody');
  const statusSpan = document.getElementById('status');

  const severityMap = {0:'INFO',1:'CRITICAL',2:'SEVERE',3:'MAJOR',4:'MINOR',5:'WARNING',6:'NORMAL'};
  const severityColors = {0:'#ffffff',1:'#ff5555',2:'#ff9900',3:'#ffff55',4:'#ff55ff',5:'#55ffff',6:'#55ff55'};

  const rowMap = new Map();
  let socket, loadedOffset=0;
  let updateBuffer=[], processing=false;
  let requesting=false;
  let maxId=0;
  let selectedRows = new Set();

  function connect() {
    socket = new WebSocket(wsUrl);
    const statusIcon = document.getElementById('statusIcon');
    socket.addEventListener('open', ()=>{
      setStatusIcon(true);
      statusIcon.textContent = '‚úÖ';
      statusIcon.style.color = '#55ff55';
    });
    socket.addEventListener('message', ev=>{
      try{
        const msg = JSON.parse(ev.data);
        if(msg.type==='init'){ renderInitial(msg.rows); loadedOffset=msg.rows.length; }
        else if(msg.type==='page'){ appendRows(msg.rows); loadedOffset+=msg.rows.length; requesting=false; }
        else if(msg.type==='update'){ queueUpdates(msg.rows); }
      }catch(e){ console.error('WS parse error',e); }
    });
    socket.addEventListener('close', ()=>{
      setStatusIcon(false);
      statusIcon.textContent = '‚ùå';
      statusIcon.style.color = '#ff5555';
      setTimeout(connect,2000);
    });
    socket.addEventListener('error', err=>console.error('WS error', err));
  }

  function createRow(r) {
    const tr = document.createElement('tr');
    tr.dataset.id = r.id;
    tr.dataset.nodeId = r.node_id;
    tr.dataset.eventname = r.eventname;
    tr.className = 'sev-'+(r.severity??0);
    const tdActive = document.createElement('td');
    const dot = document.createElement('span');
    dot.className='dot'+(r.active==1?'':' hidden');
    dot.style.backgroundColor = severityColors[r.severity] || '#fff';
    tdActive.appendChild(dot);
    tr.appendChild(tdActive);

    const tdSeverity=document.createElement('td'); tdSeverity.textContent=severityMap[r.severity]||'info'; tr.appendChild(tdSeverity);
    const tdTrap=document.createElement('td'); tdTrap.textContent=r.traptime||''; tr.appendChild(tdTrap);
    const tdHost=document.createElement('td'); tdHost.textContent=r.hostname||''; tr.appendChild(tdHost);
    const tdIp=document.createElement('td'); tdIp.textContent=r.agentip||''; tr.appendChild(tdIp);
    const tdFormat=document.createElement('td'); tdFormat.textContent=r.formatline||''; tr.appendChild(tdFormat);

    tr.style.color = severityColors[r.severity] || '#fff';
    return tr;
  }

  function renderInitial(rows) {
    tbody.innerHTML='';
    rowMap.clear();
    rows.sort((a,b)=>b.id-a.id);
    rows.forEach(r=>{
      const tr=createRow(r);
      tbody.appendChild(tr);
      rowMap.set(String(r.id), tr);
      if(r.id>maxId) maxId=r.id;
    });
    updateRowVisibility()
  }

  function appendRows(rows){
    console.debug(`[DEBUG] appendRows called with ${rows.length} rows`);
    rows.sort((a,b)=>b.id-a.id);
    rows.forEach(r=>{
      const idStr=String(r.id);
      if(rowMap.has(idStr)) return;
      const tr=createRow(r);
      tbody.appendChild(tr);
      rowMap.set(idStr, tr);
      if(r.id>maxId) maxId=r.id;
    });
    updateRowVisibility()
  }

  function queueUpdates(rows){
    console.debug(`[DEBUG] queueUpdates called with ${rows.length} rows`);
    updateBuffer.push(...rows);
    if(!processing){ processing=true; requestAnimationFrame(processBuffer); }
  }

  function processBuffer(){
    console.debug(`[DEBUG] processBuffer called with buffer size ${updateBuffer.length}`);
    const items = updateBuffer.splice(0, updateBuffer.length);
    let added = 0, updated = 0;

    items.forEach(r => {
      const idStr = String(r.id);
      const existing = rowMap.get(idStr);

      if(existing){
        updated++;
        const td = existing.children;
        td[0].querySelector('.dot').className = 'dot' + (r.active == 1 ? '' : ' hidden');
        td[0].querySelector('.dot').style.backgroundColor = severityColors[r.severity] || '#fff';
        td[1].textContent = severityMap[r.severity] || 'info';
        td[2].textContent = r.traptime || '';
        td[3].textContent = r.hostname || '';
        td[4].textContent = r.agentip || '';
        td[5].textContent = r.formatline || '';

        // ‚úÖ PATCH: aggiorna i dataset anche sugli update live
        existing.dataset.nodeId = r.node_id;
        existing.dataset.eventname = r.eventname;

        setTimeout(() => existing.classList.remove('updated'), 700);
      } else {
        if(r.id > maxId){
          added++;
          const tr = createRow(r);

          // ‚úÖ PATCH: assicura anche qui i dataset
          tr.dataset.nodeId = r.node_id;
          tr.dataset.eventname = r.eventname;

          tbody.insertBefore(tr, tbody.firstChild);
          rowMap.set(idStr, tr);
          maxId = r.id;
        }
      }
    });

    if(added > 0 || updated > 0) {
      console.debug(`[DEBUG Client] nuove=${added}, aggiornate=${updated}, totali=${added+updated}`);
    }

    updateRowVisibility();
    processing = false;
    if(updateBuffer.length > 0) requestAnimationFrame(processBuffer);
  }


    const tableWrap=document.getElementById('tableWrap');
    tableWrap.addEventListener('scroll',()=>{
      if(!socket || socket.readyState!==WebSocket.OPEN) return;
      const threshold=300;
      if(tableWrap.scrollTop + tableWrap.clientHeight + threshold >= tableWrap.scrollHeight){
        if(!requesting){
          requesting = true;
          const pageSizeToUse = (activeFilter !== null || hostInput.value.trim() || ipInput.value.trim())
          ? 999999  // o 0 se il server lo interpreta come "no limit"
          : PAGE_SIZE;
          socket.send(JSON.stringify({
            type: 'getPage',
            offset: loadedOffset,
            pageSize: pageSizeToUse,
            severity: activeFilter,
            hostname: hostInput.value.trim() || null,
            agentip: ipInput.value.trim() || null
          }));
        }
      }
    });

  // Gestione selezione multipla righe con click
  tbody.addEventListener('click', e => {
    const tr = e.target.closest('tr');
    if(!tr) return;

    if(e.ctrlKey || e.metaKey){ // Selezione multipla Ctrl/Cmd
      if(selectedRows.has(tr)){
        selectedRows.delete(tr);
        tr.classList.remove('selected');
      } else {
        selectedRows.add(tr);
        tr.classList.add('selected');
      }
    } else if(e.shiftKey){ // Selezione intervallo
      const last = Array.from(selectedRows).pop();
      if(last){
        let inRange=false;
        Array.from(tbody.children).forEach(row=>{
          if(row===last || row===tr) inRange = !inRange;
          if(inRange || row===tr) selectedRows.add(row);
          row.classList.toggle('selected', selectedRows.has(row));
        });
      } else {
        selectedRows.add(tr);
        tr.classList.add('selected');
      }
    } else { // Selezione singola
      tbody.querySelectorAll('tr.selected').forEach(r=>r.classList.remove('selected'));
      selectedRows.clear();
      selectedRows.add(tr);
      tr.classList.add('selected');
    }
  });

  // CONTEXT MENU
  const contextMenu = document.createElement('div');
  contextMenu.style.position='fixed';
  contextMenu.style.background='#222';
  contextMenu.style.border='1px solid #555';
  contextMenu.style.padding='4px 0';
  contextMenu.style.display='none';
  contextMenu.style.zIndex='1000';
  contextMenu.style.color='#fff';
  contextMenu.style.minWidth='140px';
  contextMenu.style.fontSize='13px';
  document.body.appendChild(contextMenu);

  const menuItems = [
    {label:'ACKNOWLEDGE', icon:'‚úÖ', action:()=>{
        const ids = Array.from(selectedRows).map(r=>r.dataset.id);
        const nodeIds = Array.from(selectedRows).map(r=>r.dataset.nodeId);
        const eventname = Array.from(selectedRows).map(r=>r.dataset.eventname);
        console.debug('Acknowledge rows', ids, nodeIds, eventname);
        if(socket && socket.readyState === WebSocket.OPEN){
          socket.send(JSON.stringify({
            type: 'acknowledge',
            rowIds: ids,
            nodeIds: nodeIds,
            eventname: eventname  
          }));
        }

        // Aggiorna visivamente le righe nella tabella: active = 0
        selectedRows.forEach(r=>{
          r.children[0].querySelector('.dot').classList.add('hidden');
        });
        selectedRows.clear();
      }
    },

    {label:'COPY MESSAGE', icon:'üìã', action:()=>{ 
      const text = Array.from(selectedRows).map(r=>r.children[5].textContent).join('\n');
      navigator.clipboard.writeText(text);
    }},
    {label:'DELETE', icon:'üóëÔ∏è', action:()=>{ Array.from(selectedRows).forEach(r=>r.remove()); selectedRows.clear(); }}
  ];


  /* ciclo che crea le voci del context menu */
  menuItems.forEach(item=>{
    const div = document.createElement('div');
    div.style.display='flex';
    div.style.alignItems='center';
    div.style.padding='6px 8px';
    div.style.marginBottom='2px';
    div.style.cursor='pointer';

    // Icona
    const iconSpan = document.createElement('span');
    iconSpan.textContent = item.icon;  // emoji
    iconSpan.style.marginRight = '6px';
    div.appendChild(iconSpan);

    // Testo
    const textSpan = document.createElement('span');
    textSpan.textContent = item.label;
    div.appendChild(textSpan);

    div.addEventListener('mouseenter',()=>div.style.background='#555');
    div.addEventListener('mouseleave',()=>div.style.background='transparent');
    div.addEventListener('click',()=>{
      item.action();
      contextMenu.style.display='none';
    });

    contextMenu.appendChild(div);
  });


  tbody.addEventListener('contextmenu', e=>{
    e.preventDefault();
    const tr = e.target.closest('tr');
    if(tr && !selectedRows.has(tr)){
      tbody.querySelectorAll('tr.selected').forEach(r=>r.classList.remove('selected'));
      selectedRows.clear();
      selectedRows.add(tr);
      tr.classList.add('selected');
    }
    contextMenu.style.top = e.clientY+'px';
    contextMenu.style.left = e.clientX+'px';
    contextMenu.style.display='block';
  });

  // Nascondi menu cliccando altrove
  document.addEventListener('click', ()=>contextMenu.style.display='none');

  connect();

  const filterButtons = document.querySelectorAll('.filter-btn');
  let activeFilter = null;

  filterButtons.forEach(btn => {
    const sev = parseInt(btn.getAttribute('data-severity'));
    btn.title = `Eventi ATTIVI con severity ${severityMap[sev] || 'INFO'}`;
    btn.addEventListener('click', () => {
      const severity = parseInt(btn.getAttribute('data-severity'));

      // Toggle logica filtro
      if (activeFilter === severity) {
        activeFilter = null; // disabilita filtro
        btn.classList.remove('active');
      } else {
        activeFilter = severity;
        filterButtons.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
      }

      // Richiedi pagina filtrata al server
      if (socket && socket.readyState === WebSocket.OPEN) {
        tbody.innerHTML = ''; // pulisci tabella
        rowMap.clear();
        loadedOffset = 0;
        const pageSizeToUse = (activeFilter !== null || hostInput.value.trim() || ipInput.value.trim())
        ? 999999  // o 0 se il server lo interpreta come "no limit"
        : PAGE_SIZE;
        socket.send(JSON.stringify({
          type: 'getPage',
          offset: 0,
          pageSize: pageSizeToUse,
          severity: activeFilter
        }));
      }
    });
  });

  /* Visualizza o nascondi Header Tabella eventi */
  const toggleHeaderBtn = document.getElementById('toggleHeaderBtn');
  const tableHeader = document.querySelector('table thead');
  const eyeIcon = document.getElementById('eyeIcon');

  // Nascondi header di default
  let headerVisible = false;
  eyeIcon.innerHTML = `
    <path d="M17.94 17.94A10.94 10.94 0 0 1 12 20c-7 0-11-8-11-8a20.15 20.15 0 0 1 5.06-6.06"></path>
    <line x1="1" y1="1" x2="23" y2="23"></line>
  `;

  toggleHeaderBtn.addEventListener('click', () => {
    headerVisible = !headerVisible;
    tableHeader.style.display = headerVisible ? '' : 'none';

    // Cambia icona
    if(headerVisible){
      eyeIcon.innerHTML = `
        <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
        <circle cx="12" cy="12" r="3"></circle>
      `;
    } else {
      eyeIcon.innerHTML = `
        <path d="M17.94 17.94A10.94 10.94 0 0 1 12 20c-7 0-11-8-11-8a20.15 20.15 0 0 1 5.06-6.06"></path>
        <line x1="1" y1="1" x2="23" y2="23"></line>
      `;
    }
  });

  /* StausIcon informazione */
  const statusIcon = document.getElementById('statusIcon');
  const serverIp = location.hostname; // oppure un IP fisso, es. '192.168.1.185'

  function setStatusIcon(connected) {
    if (connected) {
      statusIcon.textContent = '‚úÖ';
      statusIcon.style.color = '#55ff55';
      statusIcon.title = `Server ${serverIp} connesso`;
    } else {
      statusIcon.textContent = '‚ùå';
      statusIcon.style.color = '#ff5555';
      statusIcon.title = `Server ${serverIp} disconnesso`;
    }
  }

  /* Gestione Filtri Hostname e IP */
  const hostInput = document.getElementById('filterHost');
  const ipInput = document.getElementById('filterIP');

  function sendFilteredRequest() {
    console.debug('[DEBUG] sendFilteredRequest called. activeFilter:', activeFilter, 'host:', hostInput.value, 'ip:', ipInput.value);
    tbody.innerHTML = '';
    rowMap.clear();
    loadedOffset = 0;
    const pageSizeToUse = (activeFilter !== null || hostInput.value.trim() || ipInput.value.trim())
    ? 999999  // o 0 se il server lo interpreta come "no limit"
    : PAGE_SIZE;
    socket.send(JSON.stringify({
      type: 'getPage',
      offset: 0,
      pageSize: pageSizeToUse,
      severity: activeFilter,
      hostname: hostInput.value.trim() || null,
      agentip: ipInput.value.trim() || null
    }));
  }

  // ENTER per applicare filtro
  [hostInput, ipInput].forEach(input => {
    input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        sendFilteredRequest();
      }
      if (e.key === 'Escape') {
        input.value = '';
        sendFilteredRequest();
      }
    });
  });

  function matchesCurrentFilters(tr) {
    // tr: DOM tr element
    let sev = parseInt(tr.className.replace(/[^0-9]/g,'')) || 0;
    let host = tr.children[3].textContent || '';
    let ip = tr.children[4].textContent || '';
    let active = !(tr.children[0].querySelector('.dot').classList.contains('hidden'));
    // Se almeno un filtro √® attivo, mostra solo se active=1 e tutti i filtri corrispondono
    const hasFilter = (activeFilter !== null) || hostInput.value.trim() || ipInput.value.trim();
    if (hasFilter) {
      if (!active) return false;
      if (activeFilter !== null && sev !== activeFilter) return false;
      const hostVal = hostInput.value.trim().toLowerCase();
      if (hostVal && !host.toLowerCase().includes(hostVal)) return false;
      const ipVal = ipInput.value.trim().toLowerCase();
      if (ipVal && !ip.toLowerCase().includes(ipVal)) return false;
      return true;
    }
    // Se nessun filtro attivo, mostra sempre
    return true;
  }
  function updateRowVisibility() {
    console.debug('[DEBUG] updateRowVisibility called. activeFilter:', activeFilter, 'host:', hostInput.value, 'ip:', ipInput.value);
    // Se nessun filtro attivo, mostra tutto
    const hasFilter = (activeFilter !== null) || hostInput.value.trim() || ipInput.value.trim();
    tbody.querySelectorAll('tr').forEach(tr => {
      if (!hasFilter) {
        tr.style.display = '';
      } else {
        tr.style.display = matchesCurrentFilters(tr) ? '' : 'none';
      }
    });
  }

  // Bottone reset filtri (JS)
  const resetFiltersBtn = document.getElementById('resetFilters');
  if (resetFiltersBtn) {
    resetFiltersBtn.addEventListener('click', () => {
      // Reset severity
      activeFilter = null;
      filterButtons.forEach(b => b.classList.remove('active'));
      // Reset text
      hostInput.value = '';
      ipInput.value = '';
      // Richiedi pagina completa
      // Richiedi pagina filtrata al server
      if (socket && socket.readyState === WebSocket.OPEN) {
        tbody.innerHTML = ''; // pulisci tabella
        rowMap.clear();
        loadedOffset = 0;
        const pageSizeToUse = (activeFilter !== null || hostInput.value.trim() || ipInput.value.trim())
        ? 999999  // o 0 se il server lo interpreta come "no limit"
        : PAGE_SIZE;
        socket.send(JSON.stringify({
          type: 'getPage',
          offset: 0,
          pageSize: pageSizeToUse,
          severity: activeFilter
        }));
      }
    });
  }


})();
</script>
</body>
</html>
