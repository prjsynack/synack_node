<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>rcv_log live viewer (virtual)</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 0; padding: 0; background: #111; color: #fff; }

    #top {
      padding: 10px;
      background:#222;
      color: #fff;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .status-icon {
      font-size: 18px;
      margin-right: 10px;
    }


    /*#top { padding: 10px; background:#222; color: #fff; } */
    #tableWrap { height: calc(100vh - 50px); overflow: auto; background: #111; }
    table { width: 100%; border-collapse: collapse; color: #fff; }
    th, td { padding: 6px 8px; border-bottom: 1px solid #333; font-size: 13px; text-align: left; }
    th { position: sticky; top: 0; background: #222; z-index: 2; }

    th:nth-child(1), td:nth-child(1) { width: 15px; }
    th:nth-child(2), td:nth-child(2) { width: 80px; }
    th:nth-child(3), td:nth-child(3) { width: 140px; }
    th:nth-child(4), td:nth-child(4) { width: 200px; }
    th:nth-child(5), td:nth-child(5) { width: 120px; }
    th:nth-child(6), td:nth-child(6) { width: auto; }

    th:nth-child(1), th:nth-child(3), th:nth-child(6) { color: transparent; }

    .sev-0 { color: #ffffff; }
    .sev-1 { color: #ff5555; }
    .sev-2 { color: #ff9900; }
    .sev-3 { color: #ffff55; }
    .sev-4 { color: #ff55ff; }
    .sev-5 { color: #55ffff; }
    .sev-6 { color: #55ff55; }

    .dot { display:inline-block; width:10px; height:10px; border-radius:50%; vertical-align: middle; }
    .dot.hidden { visibility:hidden; }

    /* Minor performance tweak: prevent text selection during fast scroll */
    #tableWrap, table { -webkit-user-select: none; -moz-user-select: none; user-select: none; }
  </style>
</head>
<body>
<div id="top">
  <strong>SynAck</strong>
  <span id="statusIcon" class="status-icon">❌</span>
</div>

<div id="tableWrap">
  <table>
    <thead>
      <tr>
        <th>Active</th><th>Severity</th><th>Traptime</th><th>Hostname</th><th>Agent IP</th><th>Formatline</th>
      </tr>
    </thead>
    <tbody id="tbody"></tbody>
  </table>
</div>

<script>
(() => {
  const wsUrl = (location.protocol==='https:'?'wss':'ws')+'://'+location.host+'/ws';
  const PAGE_SIZE = 50;
  const tbody = document.getElementById('tbody');
  const tableWrap = document.getElementById('tableWrap');
  const statusSpan = document.getElementById('status');

  const severityMap = {0:'INFO',1:'CRITICAL',2:'SEVERE',3:'MAJOR',4:'MINOR',5:'WARNING',6:'NORMAL'};
  const severityColors = {0:'#ffffff',1:'#ff5555',2:'#ff9900',3:'#ffff55',4:'#ff55ff',5:'#55ffff',6:'#55ff55'};

  // Virtualization state
  let allRows = [];            // array of row objects, sorted DESC by id (newest first)
  let socket;
  let loadedOffset = 0;        // how many rows fetched by pages (initial + page requests)
  let updateBuffer = [];       // buffer for incoming updates
  let processing = false;
  let rowHeight = 0;           // computed automatically
  let visibleStart = 0;        // index in allRows of first rendered row
  let visibleEnd = -1;         // index of last rendered row
  const bufferRows = 8;        // how many extra rows to render before/after viewport to avoid popping
  const maxVisible = 1000;     // safety cap
  let maxId = 0;

  // Helper: create a TR for a row
  function createRow(r) {
    const tr = document.createElement('tr');
    tr.dataset.id = r.id;
    tr.className = 'sev-'+(r.severity??0);

    const tdActive = document.createElement('td');
    const dot = document.createElement('span');
    dot.className='dot'+(r.active==1?'':' hidden');
    dot.style.backgroundColor = severityColors[r.severity] || '#fff';
    tdActive.appendChild(dot);
    tr.appendChild(tdActive);

    const tdSeverity=document.createElement('td'); tdSeverity.textContent=severityMap[r.severity]||'info'; tr.appendChild(tdSeverity);
    const tdTrap=document.createElement('td'); tdTrap.textContent=r.traptime||''; tr.appendChild(tdTrap);
    const tdHost=document.createElement('td'); tdHost.textContent=r.hostname||''; tr.appendChild(tdHost);
    const tdIp=document.createElement('td'); tdIp.textContent=r.agentip||''; tr.appendChild(tdIp);
    const tdFormat=document.createElement('td'); tdFormat.textContent=r.formatline||''; tr.appendChild(tdFormat);

    tr.style.color = severityColors[r.severity] || '#fff';
    return tr;
  }

  // Binary search to find index by id (allRows sorted desc)
  function findIndexById(id) {
    let lo = 0, hi = allRows.length - 1;
    while (lo <= hi) {
      const mid = Math.floor((lo + hi) / 2);
      const midId = allRows[mid].id;
      if (midId === id) return mid;
      if (midId < id) { // midId smaller since DESC: target bigger -> go left
        hi = mid - 1;
      } else {
        lo = mid + 1;
      }
    }
    return -1;
  }

  // Insert new row (id > existing max) at head (maintain DESC). Returns true if inserted.
  function insertNewRowAtHead(r) {
    if (allRows.length === 0 || r.id > allRows[0].id) {
      allRows.unshift(r);
      return true;
    }
    // otherwise find correct position to keep DESC order
    let i = 0;
    while (i < allRows.length && allRows[i].id > r.id) i++;
    allRows.splice(i, 0, r);
    return true;
  }

  // Append older rows at tail (pages come with ORDER BY id DESC)
  function appendPageRows(rows) {
    // rows already sorted desc; we should push elements that we don't have
    for (const r of rows) {
      if (findIndexById(r.id) === -1) {
        allRows.push(r);
      }
    }
  }

  // Update or add incoming update row(s)
  function applyUpdateRow(r) {
    const idx = findIndexById(r.id);
    if (idx !== -1) {
      // update existing object (preserve array position)
      allRows[idx] = r;
      return { type: 'updated', index: idx };
    } else {
      // new row (more recent) -> insert at head
      insertNewRowAtHead(r);
      return { type: 'inserted', index: 0 };
    }
  }

  // Render visible window (virtualized)
  function renderVisible() {
    if (rowHeight === 0) return; // not measured yet

    const scrollTop = tableWrap.scrollTop;
    const viewportHeight = tableWrap.clientHeight;
    const rowsPerScreen = Math.max(1, Math.ceil(viewportHeight / rowHeight));
    const start = Math.max(0, Math.floor(scrollTop / rowHeight) - bufferRows);
    const end = Math.min(allRows.length - 1, start + rowsPerScreen + bufferRows * 2);
    // safety cap
    const actualCount = Math.min(maxVisible, end - start + 1);

    // If viewport unchanged, skip re-render
    if (start === visibleStart && (start + actualCount - 1) === visibleEnd) {
      return;
    }

    visibleStart = start;
    visibleEnd = start + actualCount - 1;

    // compute spacer heights
    const topHeight = start * rowHeight;
    const bottomHeight = Math.max(0, (allRows.length - 1 - visibleEnd) * rowHeight);

    // build DOM: top spacer tr, visible rows, bottom spacer tr
    tbody.innerHTML = '';

    // top spacer
    const topTr = document.createElement('tr');
    const topTd = document.createElement('td');
    topTd.colSpan = 6;
    topTd.style.height = topHeight + 'px';
    topTd.style.border = 'none';
    topTr.appendChild(topTd);
    tbody.appendChild(topTr);

    // visible rows
    for (let i = visibleStart; i <= visibleEnd && i < allRows.length; i++) {
      const r = allRows[i];
      const tr = createRow(r);
      tbody.appendChild(tr);
    }

    // bottom spacer
    const botTr = document.createElement('tr');
    const botTd = document.createElement('td');
    botTd.colSpan = 6;
    botTd.style.height = bottomHeight + 'px';
    botTd.style.border = 'none';
    botTr.appendChild(botTd);
    tbody.appendChild(botTr);
  }

  // measure row height automatically by creating one sample row
  function measureRowHeight(sampleRowData) {
    const tr = createRow(sampleRowData || { id: 'sample', active:1, severity:0, traptime:'', hostname:'', agentip:'', formatline:'sample' });
    tbody.innerHTML = '';
    tbody.appendChild(tr);
    // force layout measure
    rowHeight = tr.getBoundingClientRect().height || tr.offsetHeight || 24;
    // clear tbody (will be re-rendered)
    tbody.innerHTML = '';
    // ensure minimal sane value
    if (!rowHeight || rowHeight < 8) rowHeight = 24;
  }

  // process buffered updates: merge into allRows then re-render visible region if needed
  function processBuffer() {
    const items = updateBuffer.splice(0, updateBuffer.length);
    if (items.length === 0) { processing = false; return; }

    let needRender = false;
    for (const r of items) {
      const res = applyUpdateRow(r);
      // track maxId for new rows
      if (r.id > maxId) maxId = r.id;
      // if update affects visible range, mark rendering needed
      if (res.type === 'inserted') {
        needRender = true; // insert at head affects offsets
      } else if (res.type === 'updated') {
        if (res.index >= visibleStart && res.index <= visibleEnd) needRender = true;
      }
    }

    if (needRender) renderVisible();
    processing = false;
    if (updateBuffer.length > 0) requestAnimationFrame(processBuffer);
  }

  function queueUpdates(rows) {
    updateBuffer.push(...rows);
    if (!processing) { processing = true; requestAnimationFrame(processBuffer); }
  }

  // handle server messages
  function handleMessage(msg) {
    if (msg.type === 'init') {
      // server sends initial page (most recent PAGE_SIZE rows)
      allRows = msg.rows.slice(); // assume already sorted desc by server
      if (allRows.length > 0) {
        maxId = Math.max(...allRows.map(r => r.id || 0), maxId);
      }
      loadedOffset = allRows.length;
      // measure rowHeight automatically using first row
      measureRowHeight(allRows[0]);
      renderVisible();
    } else if (msg.type === 'page') {
      // append older rows
      appendPageRows(msg.rows || []);
      loadedOffset += (msg.rows || []).length;
      renderVisible();
    } else if (msg.type === 'update') {
      queueUpdates(msg.rows || []);
      // don't call render immediately; will be done by processBuffer
    } else if (msg.type === 'error') {
      console.error('Server error:', msg.message);
    } else {
      console.warn('Unknown message type', msg.type);
    }
  }

  // connect websocket
  function connect() {
    socket = new WebSocket(wsUrl);
    const statusIcon = document.getElementById('statusIcon');
    // socket.addEventListener('open', ()=> { statusSpan.textContent = 'connesso: sì'; });
    socket.addEventListener('open', ()=>{
      statusIcon.textContent = '✅';
      statusIcon.style.color = '#55ff55';
    });
    socket.addEventListener('message', ev=>{
      try {
        const msg = JSON.parse(ev.data);
        handleMessage(msg);
      } catch (e) {
        console.error('WS parse error', e);
      }
    });
    socket.addEventListener('close', ()=>{
      statusIcon.textContent = '❌';
      statusIcon.style.color = '#ff5555';
      setTimeout(connect,2000);
    });
    socket.addEventListener('error', err => console.error('WS error', err));
  }

  // infinite scroll: request older pages when near bottom
  tableWrap.addEventListener('scroll', () => {
    // renderVisible on scroll (throttled via rAF)
    requestAnimationFrame(renderVisible);

    if (!socket || socket.readyState !== WebSocket.OPEN) return;
    const threshold = 300;
    if (tableWrap.scrollTop + tableWrap.clientHeight + threshold >= tableWrap.scrollHeight) {
      // request older page
      socket.send(JSON.stringify({ type: 'getPage', offset: loadedOffset, pageSize: PAGE_SIZE }));
    }
  });

  // initial connect
  connect();
})();
</script>
</body>
</html>
